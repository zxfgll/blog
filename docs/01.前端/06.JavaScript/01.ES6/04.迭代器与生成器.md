## 可迭代协议

通常来说我们会用 `for` 循环来遍历一个数组，js内部是怎样判断一个对象是否可遍历呢？答案是 `@@iterator`属性方法（私有），可以通过常量 `Symbol.iterator` 访问它。

> [Symbol.iterator] : 一个无参数的函数，其返回值为一个符合[迭代器协议](#迭代器协议)的对象。

在迭代一个对象时，会不带参数的调用它的 `@@iterator`方法，这个方法会返回一个[迭代器（包含next方法）]()，最终返回迭代器中的value值作为当前遍历的结果。

![](https://linyc.oss-cn-beijing.aliyuncs.com/20220527173650.png)

::: tip
可以直接将 `Symbol.iterator` 和 `@@iterator` 划等号
:::


## 迭代器协议

实现了迭代器协议的对象才能被成为迭代器，迭代器协议要求实现一个`next()`方法给 `for` 循环调用，next方法必须返回一个以下格式的对象：

```js
function next(){
    return {
        done : boolean,
        value : any ,
    }
}
```

例如，实现一个1-3的迭代器：

<<< @/codes/javaScript/es6/iterator.js#objectIterator

解读：
-   `Symbol.iterator`返回`this`
-   this指向当前这个携带 `next` 方法的对象
-   当前对象成为一个迭代器

![](https://linyc.oss-cn-beijing.aliyuncs.com/20220527173904.png)

同理，我们可以将一个class类转换为可迭代对象：

<<< @/codes/javaScript/es6/iterator.js#class

## 生成器generator

生成器带有 `*` 号，生成器返回一个迭代对象，带有`next()`方法和`Symbol.iterator()`方法。它可以这样定义：

<<<@/codes/javaScript/es6/generator.js#basic

关于`yield`，见下图：

![](https://linyc.oss-cn-beijing.aliyuncs.com/20220527175501.png)

::: tip
如果使用for循环而不是直接调用next方法，js会帮我们拿到返回对象{done : boolean , value : any} 中的`value` ———— 和前面我们自己实现的迭代器一样。
:::

## Symbol.asyncIterator

> Symbol.asyncIterator 符号指定了一个对象的默认异步迭代器。如果一个对象设置了这个属性，它就是异步可迭代对象，可用于for await...of循环。

当然，`Symbol.asyncIterator` 不能只是一个null或undefined，它应该定义

