---
title: 标准redux模式
date: 2022-05-16 11:45:22
permalink: /pages/71277a/
categories:
  - 前端
  - React
  - Redux
tags:
  - 
---

## store

`configureStore` 的可选项：
```javaScript
export interface ConfigureStoreOptions {
    /**
     * A single reducer function that will be used as the root reducer, or an
     * object of slice reducers that will be passed to `combineReducers()`.
     */
    reducer: Reducer<S, A> | ReducersMapObject<S, A>;
    /**
     * An array of Redux middleware to install. If not supplied, defaults to
     * the set of middleware returned by `getDefaultMiddleware()`.
     */
    middleware?: ((getDefaultMiddleware: CurriedGetDefaultMiddleware<S>) => M) | M;
    /**
     * Whether to enable Redux DevTools integration. Defaults to `true`.
     *
     * Additional configuration can be done by passing Redux DevTools options
     */
    devTools?: boolean | DevToolsOptions;
    /**
     * The initial state, same as Redux's createStore.
     * You may optionally specify it to hydrate the state
     * from the server in universal apps, or to restore a previously serialized
     * user session. If you use `combineReducers()` to produce the root reducer
     * function (either directly or indirectly by passing an object as `reducer`),
     * this must be an object with the same shape as the reducer map keys.
     */
    preloadedState?: PreloadedState<CombinedState<NoInfer<S>>>;
    /**
     * The store enhancers to apply. See Redux's `createStore()`.
     * All enhancers will be included before the DevTools Extension enhancer.
     * If you need to customize the order of enhancers, supply a callback
     * function that will receive the original array (ie, `[applyMiddleware]`),
     * and should return a new array (such as `[applyMiddleware, offline]`).
     * If you only need to add middleware, you can use the `middleware` parameter instead.
     */
    enhancers?: StoreEnhancer[] | ConfigureEnhancersCallback;
}

```

`enhancers`允许我们为原有的`dispatch, getState, and subscribe`添加一些新特性.但多数情况下，我们只需修改`dispatch`即可，而在这方面上，使用`middleware`是个更好的选择。

## middleware

es6的`generate` 特性让中间件在`nodejs`中变得十分流行，在完成了中间件功能后，可以直接调用`next()`来进入下一个流程。它让所有任务能够**链式调用**。在redux中我们主要使用中间件来处理`dispatch action`到 `reducer`之间的流程。

## Flux Standard Actions

`Flux` 来自于拉丁语的 `Flow`，意思是 **数据和逻辑永远单向流动** ， `Flux standart actions` 即按照 `Flux`标准的 `redux-actions`

`Redux store`其实不在意你在 `action` 中放置了哪些属性，它只关心 `action.type`。但如果对 `action` 的属性值没有任何规范的话，我们就很难提前知道自己要如何处理每一个 `reducer` 中的数据。因此我们需要一个`Flux`标准，标准如下：

**数据存放**：
-   如果有 `data`，请放在 `action.payload` 中
-   `action.meta`存放额外的描述信息，可选
-   `action.error`：布尔值，是否发生错误，若发生错误，`payload`存放error信息 ，可选

:::tip
在redux社区中， `action.error`的应用并不广泛，设计者更倾向于用分离 `action`来解决问题。例如：

定义成功请求的 `action` 为 `'todos/todosLoadingSucceeded'`，并在相应 `reducer`中处理

定义失败请求的 `action` 为 `'todos/todosLoadingFailed'`，并在相应 `reducer`中处理
:::


**必填项**
-   `action`必须是一个扁平的 `javaScript object` , 
-   `action`必须有`type`属性






