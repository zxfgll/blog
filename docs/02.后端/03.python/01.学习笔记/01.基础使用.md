---
title: python基础使用
date: 2022-05-06 19:29:02
permalink: /pages/847b47/
categories:
  - 后端
  - python
tags:
  - 
---

## 数据类型

### 字符串

```python
print(r'\t') # \t  r''表示不转义
print('\t') # 

print('''
        1
        2
        3
      ''') # 用''' 表示多行内容代替\n

s = 'abc'
s2 = s.replace('a' , 'A') # 替代
```


### 元组

元组 `tuple`和列表 `list` 非常类似，唯一的区别是它一旦初始化就不能修改。

优点：使用元组可以让你的程序更安全。

```python
t = (2, 3) 
t = (2,) # 为了区分元素和运算符括号，在声明只有一个元素的元组时会在后面加一个逗号
```

### 字典

```python
d = {foo : 'foo'} # 定义
print('bar' in d) # 是否存在
print (d.get('bar') == None)   # 是否存在
d.pop('foo') # 删除 

```

### set

```python
s = {"1","2"}
s = set([1,2,3])
s.add(4)
s.remove(4)
s2 = set([2,3,4])
print(s1 & s2) # 利用位运算符 & 取交集
print(s1 | s2) # 利用位运算符 | 取并集

# a & b ：将a和b转化为二进制，将每一位 用& 计算
# a | b : 将每一位 用| 计算

```


## 操作符

### 逻辑运算

```python
print(1 and 3)  # 3 与
print(1 or 3) # 1 或
if not a == 3 :  # 非
   print (a)

print
```

### 运算符

```python
10 / 3  # 3.33333
10 // 3  # 3 想下取整
```

### 赋值

```python
a = 1
b = 2

# 我们假设计算一个斐波拉契数列，结果应该是a = 2 , b = 3
# 写法一
temp = b
b = temp + a
a = temp

# 写法二
temp = (b,a + b)
a = temp[0]
b = temp[1]

# 写法三
a,b = b , a+b

```

### 切片
快速切割数组和类数组对象

```python
list = [1, 2, 3]
print(list[0:1])  # [1]
print(list[:1])  # [1]
print(list[-1:]) # [3] 
print(list[:])  # [1,2,3] 复制

tuple = (1,2,3)
print(tuple[0:1]) # (1)

str = "123"
print(str[0:1]) # 1

```
- `list[x,y]` 能够快速取数组的第 x 位到第 y 位
- 从头开始时，x 可以省略，到尾结束时，y可以省略
- `tuple,string` 同 `list`


### 迭代

```python
obj = {'a': 1, 'b': 2}
for key in obj:  # 按键迭代
  print(key)

for value in obj.values(): # 按值迭代
  print(value)

for k,v in obj: # 按键值迭代
  print(k , v) 

from collections.abc import Iterable

print(isinstance('abc' , Iterable))  # 是否可迭代

```

### 三目运算符

```js
const a = 1
const res = a > 0 ? '正数' : '非正数' 
```

```python
a = 1
res = '正数' if a > 0 else '非正数' 
# 正常结果 【判断语句】 异常结果 
```

### if-else 简写

**赋值语句**
```python
status = "completed"

if status == "loading":
   ready = False
elif status == "rejected":
   ready = False
else :
   ready = True

# 简写
ready = False if status == "loading" else False if status == "rejected" else True  

```
断句为：
- ready = 
- False if status == "loading"
- else 
- False if status == "rejected"
- else
- True


### 列表生成

<<< @/codes/python-demo/list_comprehensions.py

### 生成器

<<< @/codes/python-demo/generator.py

### map/reduce/filter

`map` 允许我们传入两个参数,`map(处理函数，可迭代对象)`, map将会为可迭代对象的每个元素套用处理函数，并返回一个新的map，map是一个 **惰性序列**。

```python
def f(x):
    return x * x
r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9]) # r  = <map object at 0x000001E91CEDF280>
list(r) # [1, 4, 9, 16, 25, 36, 49, 64, 81]
```

惰性序列比较像js中的闭包函数————函数返回一个新函数，新函数不会立即执行而是到了引用时再执行 , 惰性序列也是同理，如果你不主动遍历它，他就不会计算其中元素的值，只是保留一个用户输入的表达式。

```python
    def m_g():
        num = 1
        while True:
            yield num + 1
    
    it = m_g() 

    res = map(lambda x: x*x , it) # 生成器可以被无限迭代 ，但由于map是惰性序列，程序只保留这个式子而不执行，程序正常结束
    # print(list(res)) # 访问了map，开始计算结果，因为生成器可以被无限迭代，因此无限循环 
```

`reduce` 允许我们传入两个参数，`reduce(处理函数,数组)`，处理函数比较像js中的sort函数，它一定接收两个函数，并将两者计算的结果return出去传给下一个元素，它实际上是这样的解构：

```python
reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)
```

比如求和函数：
```python
from functools import reduce

def add(x, y):
    return x + y

res = reduce(add, [1, 2, 3])
print(res) # 6


```

`filter(处理函数，序列)`,filter和map一样是 **惰性序列**

```python
def is_odd(n):
    return n % 2 == 1

list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))
# 结果: [1, 5, 9, 15]
```

来看一个有意思的例子,用[埃拉托斯特尼筛法](https://baike.baidu.com/item/%E5%9F%83%E6%8B%89%E6%89%98%E6%96%AF%E7%89%B9%E5%B0%BC%E7%AD%9B%E6%B3%95/374984?fromtitle=%E5%9F%83%E6%8B%89%E6%89%98%E8%89%B2%E5%B0%BC%E7%AD%9B%E9%80%89%E6%B3%95&fromid=4524938)求素数：

1.  生成从2开始的自然数序列： 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, ...
2.  下一个数字是2，2的倍数一定不是素数：用filter函数把2的倍数筛掉：3, ~~4~~, 5, ~~6~~, 7, ~~8~~, 9, ~~10~~, 11, ~~12~~, 13, ~~14~~, 15, ~~16~~, 17, ~~18~~, 19, ~~20~~, ...
3.  下一个数字是3，3的倍数一定不是素数：用filter函数把3的倍数筛掉：~~4~~, 5, ~~6~~, 7, ~~8~~, ~~9~~, ~~10~~, 11, ~~12~~, 13, ~~14~~, ~~15~~, ~~16~~, 17, ~~18~~, 19, ~~20~~, ...

问题是，这个序列是无限的，我们要怎么去筛选一个无限序列呢？答案是**生成器**。

```python
    def list_queue():  # 用迭代器生成无限序列
        num = 2
        while True:
            yield num 
            num += 1

     # 高阶函数，返回一个新函数，新函数返回boolean值，让filter判断是否需要保留当前值
    def not_divisible(n): 
        return lambda x : x % n != 0  # 如果不是当前迭代到数字的倍数就保留   
    
    def primes():
        yield 2
        it = list_queue() # 构造生成器
        while True:
            num = next(it)
            yield num
            # 生成器是无限可迭代对象，它实际上是[2,3,4,5,....]无限序列
            # filter生成的结果为惰性序列，不执行，不会导致死循环
            # not_divisible将当前迭代到的数字的倍数从序列中筛除
            it = filter(not_divisible(num) , it)   

    for n in primes() :
        if  n < 100:
            print(n)
        else: # 取值时记得跳出无限序列
            break 
```

## 基本函数

### 判断变量类型

```python
x = 'abc'
y = 123

isinstance(x , str)
isinstance(y , str)
```

### 求和函数

```python
a = [1,2,3]

print(sum(a))
```

### lambda函数(匿名函数)

`lambda 入参：返回值表达式`

<<< @/codes/python-demo/lambda.py

### 类型转换

```python
a = '123'
print(int(a)) # 123
```