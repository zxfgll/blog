---
title: 面向对象编程
date: 2022-06-04 10:15:58
permalink: /pages/895ff8/
categories:
  - 后端
  - python
  - 学习笔记
tags:
  - 
sitemap:
  exclude: false
  changefreq: monthly
---

## 基础使用

```python
class Student:
    pass

bart = Student()
```

## 私有属性

我们[上一节](/pages/b5ead5/)提到过：*类中的属性如果被命名为 `_xxx,__xxx` 则会被真正转换为私有属性* ， 现在我们来尝试一下：

```python
class Student:
    def __init__(self , name , age) :
        self.name = name
        self.__age = age

bart = Student('bart' , 18)
print(bart.name)
print(bart.__age)  # AttributeError: 'Student' object has no attribute '__age'
```

事实上，`__xxx`会被python解释器转换为`_类名__xxx` 的形式。

## 私有属性的继承

我们实现一个 **Monitor类** 继承于Student类，我们为两个类都实现了 `__init__`的初始化方法，想看看实际上会调用哪一个：

```python
class Student:
    def __init__(self , name , age) :
        print('init student')
        self.__name = name
        self.__age = age

    def get_name(self):
        print(self.__name) 

class Monitor(Student):
    def __init__(self , name , age) :
        print('init monitor')
        self.__name = name
        self.__age = age


bart = Monitor('bart' , 18 )

bart.get_name()
```

结果打印出了 `monitor` 和 `报错'Monitor' object has no attribute '_Student__name'`，好了，现在我们知道会优先调用子类的构造方法。

嗯？为什么我调用继承来的方法报错了？看来python解释器在编译私有属性的时候并不是通过调用者来编译的，我们想象的情况是：

```python
bart = Monitor('bart' , 18 ) # 通过 Monitor类构造一个实例
bart.get_name() # 调用实例的get_name()方法，方法打印`self.__name`，self.__name应该是构造类的名字，应该被编译成_Monitor__name
```

实际的状况是：
```python
bart.get_name() # 调用实例的get_name()方法,方法来自于 class Student ，self.__name被编译成 _Student__name
```

好吧，那我们有三种办法解决这种情况：

1.  实现子类的 `get_name` 方法：

```python
class Monitor(Student):
    def __init__(self , name , age) :
        print('init monitor')
        self.__name = name
        self.__age = age

    def get_name(self):
        print(self.__name) 
```

2.  主动调用父类的构造方法：

```python
class Monitor(Student):
    def __init__(self , name , age) :
        super().__init__(name , age) # 调用父类的构造器
       
```

::: tip
在子类中获取父类实例有两种方法：

python3 : super()

python2 : super(子类名, self)  【(继承类，继承实例)】
:::

3.  不定义子类的构造方法，默认使用父类的构造方法

```python
class Monitor(Student):
    pass
```

关于详细私有属性的继承情况，这里有总结[python私有同名属性的继承](http://zhangming0509.github.io/2016/01/29/python-private-attribute-inherient/#:~:text=%E5%9C%A8python%E4%B8%AD%E4%BB%A5%E5%8F%8C%E4%B8%8B%E5%88%92%E7%BA%BF%E5%BC%80%E5%A4%B4%E7%9A%84%E5%B1%9E%E6%80%A7%E6%98%AF%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%EF%BC%8C%E4%B8%8D%E4%BC%9A%E8%A2%AB%E5%AD%90%E7%B1%BB%E7%BB%A7%E6%89%BF%EF%BC%8C%E7%84%B6%E8%80%8Cpython%E4%B8%AD%E7%9A%84%E7%A7%81%E6%9C%89%E4%B8%8D%E6%98%AF%E7%BB%9D%E5%AF%B9%E7%9A%84%E7%A7%81%E6%9C%89%EF%BC%8C%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%20_%E7%B1%BB%E5%90%8D__%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%20%E7%9A%84%E6%96%B9%E5%BC%8F%E8%A2%AB%E7%BB%A7%E6%89%BF%EF%BC%8C%E7%8E%B0%E6%9C%89%E5%A6%82%E4%B8%8B%E4%B8%A4%E4%B8%AA%E7%B1%BB%2C,child%20%E5%92%8C%20Father%20%EF%BC%9A)

