---
title: 面向对象
date: 2022-06-15 15:21:33
permalink: /pages/cdb894/
categories:
  - 后端
  - java
tags:
  - 
sitemap:
  exclude: false
  changefreq: monthly
---

## 修饰符

一个 `.java` 文件只能有一个 `public公有类`。

如果有public类，文件名必须和public类的名字相同。
·
## 构造方法

java中的构造方法和`c/c++`十分相似，和类同名的方法就是构造方法：

```java
public class Main {
    public static void main(String[] args) {
        Person p = new Person("Xiao Ming", 15);
    }
}

class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public Person() { // 同样相似的还有多态特性
    }
}
```

如果你想要设置属性默认值：
```java
class Person {
    private String name = "Unamed";
    private int age = 10;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
```

多态的情况下你可以通过`this`调用其他构造方法来保证不用编写重复代码：
```java
class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public Person(String name) {
        this(name, 18); // 调用另一个构造方法Person(String, int)
    }

    public Person() {
        this("Unnamed"); // 调用另一个构造方法Person(String)
    }
}

```

## 继承

java中的继承和`JavaScript`十分类似（可能应该倒过来说？）

```java

class Person {
    private String name;
    private int age;
}

class Student extends Person {
    private int score;
}
```

继承的作用域和c语言一致，**子类无法访问父类private属性，但可以访问protected属性**

### super

当子类和父类都需要初始化时，需要使用`super(参数)`来调用父类的构造方法；若没有显式调用，则子类会自动调用`super()`来执行父类的构造方法：

```java
class Person {
    protected String name;
    protected int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
}

class Student extends Person {
    protected int score;

    public Student(String name, int age, int score) {
        super(name, age); // 调用父类的构造方法Person(String, int)
        this.score = score;
    }
}

```

### 继承限制

`final class` 表示一个类不可被继承：
```java
public final class Person {...}
```

`sealed class permits [subClass name]` 表示指明后代：

```java
public sealed class Shape permits Rect, Circle, Triangle {}
public final class Ellipse extends Shape {...} // 报错
```

## 重载和覆写

名字相同，参数不同或返回值不同为 **重载** ：

```java
class Hello {
    public void hello() {
        System.out.println("Hello, world!");
    }

    public void hello(String name) {
        System.out.println("Hello, " + name + "!");
    }
}
```

名字相同，参数相同，返回值相同为 **覆写**，子类覆写父类的方法时需要加修饰符 `@Override`：
```java
class Person {
    public void run() {
        System.out.println("Person.run");
    }
}

class Student extends Person {
    @Override
    public void run() {
        System.out.println("Student.run");
    }
}
```

假设一种复杂情况：我们有一个子类`Student`和一个父类`Person`，我们用Person类型来接收一个Student实例，子类覆写了父类的`run`方法，那么当我们调用run时，调用的应该是谁的方法呢？

```java
public class Main {
    public static void main(String[] args) {
        Person p = new Student();
        p.run(); // Student.run
    }
}

class Person {
    public void run() {
        System.out.println("Person.run");
    }
}

class Student extends Person {
    @Override
    public void run() {
        System.out.println("Student.run");
    }
}
```

> Java的实例方法调用是基于运行时的实际类型的动态调用，而非变量的声明类型。

#### 不可覆写字段

```java
class Person {
    protected String name;
    public final String hello() {
        return "Hello, " + name;
    }
}

Student extends Person {
    // compile error: 不允许覆写
    @Override
    public String hello() {
    }
}
```

**可以在自身的构造方法中初始化final字段**

```java
class Person {
    public final String name;
    public Person(String name) {
        this.name = name;
    }
}
```

#### 抽象类

在定义类的时候，常常我们会选择定义一个基类，它的所有功能由子类来实现，例如：

```java
class Person {
    public void run(){};
}

class Student extends Person {
    @Override
    public void run() { … }
}

class Teacher extends Person {
    @Override
    public void run() { … }
}

```

这种时候，我们不将基类实例化使用，而只使用它的子类。基类可以被定义成一个 **抽象类** ,它只做方法属性的声明而不去实现它，我们使用 `abstract class` 和 `abstract 数据类型` 来声明一个抽象类和它的抽象方法：

```java
abstract class  Person {
    public abstract void run(){};
}
```

::: tip
子类**必须**实现抽象方法
:::

抽象类是一种**规范**，我们称之为*面向抽象编程*：
-   上层代码只定义规范
-   具体逻辑由不同的子类实现。

::: tip
好的规范可以让使用者更好理解使用的同时强化了代码的健壮性。
:::

#### 接口

抽象类和接口非常相似，接口简化了抽象类的写法，它允许你除去修饰符和关键词abstract，但小心对于子类来说应该是 **实现implements** 一个接口，而不是 **继承extends** 一个接口：

```java
// 抽象类
abstract class Person {
    public abstract void run();
    public abstract String getName();
}

class Student extends Person {
    @Override
    public void run() { … }
}

// 接口

interface Person {
    void run();
    String getName();
}

class Student implements Person {
    @Override
    public void run() { … }
}
```

java中的类没有多重继承，但可以实现多个接口：

```java
class Student implements Person, Hello { // 实现了两个interface
    ...
}
```

接口可以相互继承:

```java
interface Hello {
    void hello();
}

interface Person extends Hello {
    void run();
    String getName();
}
```

接口可以用 `default` 定义默认方法,子类可以不实现默认方法：

```java
interface Person {
    String getName();
    default void run() {
        System.out.println(getName() + " run");
    }
}
```

通常来说，接口无法生成实例，它没有自己的属性，但有一个例外：**静态字段** ：

```java
public interface Person {
    public static final int MALE = 1;
    public static final int FEMALE = 2;
}

// 因为接口的字段只可能是静态属性，所以也可以去掉修饰符，和上面写法等价
public interface Person {
    int MALE = 1;
    int FEMALE = 2;
}
```


## 内部类和匿名类

#### 内部类

如果一个类定义在另一个类的内部，这个类就是**Inner Class内部类**：

```java
class Outer {
    class Inner {
        // 定义了一个Inner Class
    }
}
```

#### 匿名类

**匿名类** 是内部类的一种，它可以**拓展一个给定的类**或者**实现一个接口**。你可以将它看作是内部类的简便写法，我们先用普通内部类写一遍代码，再用匿名类改写它：

**实现一个接口：**

```java

interface Hello{
    void hello();
};

// 内部类
class Outer{
    class Inner implements Hello{
        @Override
        public void hello() {
            System.out.println("hello!");
        }
    } 

    public void run(){
        Inner inner = new Inner();
        inner.hello();
    }
}

// 匿名类
class Outer{
    public void run(){
        Hello anonymous = new Hello(){
            public void hello() {
                System.out.println("hello!");
            };
        };
        anonymous.hello();
    }
}

```

::: tip
匿名类的实质是在**定义类的同时创建它的实例**。
:::


两个常见的匿名类使用场景：

1.  初始化`HashMap`：

```java
import java.util.HashMap;

public class HashMapDemo {
    public static void main(String[] args) {
        // 正常创建HashMap
        HashMap<String, String> map1 = new HashMap<>();
        map1.put("foo" , "foo");
        System.out.println(map1.get("foo"));

        // 使用匿名类创建HashMap
        HashMap<String , String> map2 = new HashMap<>(){
            {
                put("foo", "foo"); // 构造代码块，可以直接访问HashMap类中的put方法
            }
        };
        System.out.println(map2.get("foo"));
    }
}

```

::: tip
这里使用了一种 **双大括号** 语法,它的本质是 **构造代码块**
:::

##### 构造代码块

构造代码块就是在类中用`{}`括起来的内容，它会在构造函数执行之前运行，目的是执行一个**公有的初始化类的操作**：

```java
public class ConstructDemo {
    public static void main(String[] args) {
        Student nobody = new Student(); // 生成学生中...  ; 执行构造函数1
        Student xiaoming = new Student("xiaoming");   // 生成学生中...  ; 执行构造函数2
    }
}

class Student{
    {
        System.out.println("生成学生中...");
    }
    public Student(){
        System.out.println("执行构造函数1");
    }
    public Student(String name){
        System.out.println("执行构造函数2");
    }
}

```

:::danger
双大括号写法一定程度上使代码更简洁，但同时可能降低可读性。

并且它会创建一个带有匿名类的新子类，而额外的类并不是一种非常有效的方式。

因此最好仅在学习时使用。
:::

2.  设计多线程任务时创建一个新线程并执行匿名类：

```java
public class Main {
    public static void main(String[] args) {
        Outer outer = new Outer("Nested");
        outer.asyncHello();
    }
}

class Outer {
    private String name;

    Outer(String name) {
        this.name = name;
    }

    void asyncHello() {
        Runnable r = new Runnable() { // 实现一个Runable接口，以便线程池调用
            @Override
            public void run() {
                System.out.println("Hello, " + Outer.this.name);
            }
        };
        new Thread(r).start(); // 创建一个新线程并运行
    }
}


```